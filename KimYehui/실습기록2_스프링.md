<전반적>

<JAVA>

<스프링으로의 대-전환!>
1. AppConfig를 스프링 기반으로 변경하기
- AppConfig 클래스에 @Configuration 어노테이션 붙이기
- AppConfig 내의 모든 메서드에 @Bean 어노테이션 붙이기
  => Bean 붙인 애들이 "스프링 컨테이너"에 등록됨!
2. MemberApp을 AppConfig 버전에서 스프링 사용하는 버전으로 변경하기
- (중요*) ApplicationContext 객체를 new AnnotationConfigApplicationContext로 생성하기
  => AppConfig(=java기반)에서 annotation 기반으로 빈을 생성했었으니까!
  => 즉, AppConfig안에 Bean으로 만들어놓은 환경설정 정보를 가지고 스프링 컨테이너에서 관리한다

<개념 상세 부가 설명>
1. 스프링 컨테이너와 스프링 빈
- applicationContext : 스프링 컨테이너!
  => 스프링은 모든 게 이 ApplicationContext에서 시작한다. 얘가 스프링 컨테이너의 bean들을 관리해준다.
- 이전에는 AppConfig를 사용해 직접 객체 생성하고 DI 했지만, 이제부턴 스프링 컨테이너 통해 사용한다
- 스프링 컨테이너는 @Configuration이 붙은 AppConfig를 설정(구성)정보로 사용한다. 여기서 @Bean 붙은 메서드를 모두 호출해서 객체로 만들어 스프링 컨테이너에 등록한다. 이렇게 스프링 컨테이너에 등록된 객체를 스프링 빈이라고 함.
- 스프링 빈 : @Bean 붙은 메서드의 명을 스프링 빈 이름으로 사용함.
  *Bean 이름 바꿀 수  있음 : @Bean(name="~")식으로. (비권장)
- 이전에는 필요한 객체를 AppConfig를 사용해 직접 조회했지만, 이제부턴 스프링 컨테이너 통해 필요한 스프링 빈(객체) 찾아야 하며, 스프링 빈을 찾기 위해서는 applicationContext.getBean() 메서드를 사용한다!
- 이전에는 직접 자바코드로 모든 것을 했다면 이제부턴 스프링 컨테이너에 객체를 스프링 빈으로 등록하고, 스프링 컨테이너에서 스프링 빈을 찾아서 사용하도록 변경한다.
2. 스프링 컨테이너 사용의 장점?
(1) 스프링 컨테이너 생성
- ApplicationContext = 스프링 컨테이너 = 인터페이스
- 스프링 컨테이너는 XML 기반으로 만들수도 있고, (실습에서 했듯이) 어노테이션 기반의 자바 설정 클래스로 만들수도 있다. 전자는 최근에 잘 안쓰임.
- (실습에서 했듯이) 자바 설정 클래스 기반의 스프링 컨테이너를 만들려면,..
  -> new AnnotationConfigApplicationContext(AppConfig.class);
  -> 이 클래스는 ApplicationContext라는 인터페이스의 구현객체임!
      (ApplicationContext 클래스를 뒤져보면 여러 메서드가 있는데 그중에 위 구현객체 발견가능)
*(참고)스프링 컨테이너를 부를 때, BeanFactory, ApplicationContext로 구분해서 얘기함. BeanFactory를 직접 사용하는 경우 거의 없으므로, 일반적으로 ApplicationContext를 스프링 컨테이너라 함.
(2) 스프링 컨테이너의 생성 과정
  a. 스프링 컨테이너 생성
   : 구성정보(AppConfig같은 것) 지정 필요
  b. 스프링 빈 등록
   : 구성정보로 전달받은 메서드들을 Bean들로 등록
   * 주의 : 빈 이름은 항상 다른 이름으로 부여해야함! 중복 절대 안됨.
  c. 스프링 빈 의존관계 주입
   : 각 스프링 빈 간의 의존관계 설정하는 것.
   - 스프링 컨테이너는 설정 정보를 참고해서 의존관계를 주입한다.
   - 단순히 자바코드 호출하는 것 같지만, 차이 있음! (싱글톤에서 설명 예정)

<JUnit 테스트>
- junit5부터는 테스트 클래스나 메서드 앞에 public 생략해도 됨

<스프링 빈 조회>
(1) 모든 빈 조회해보기
- ac.getBeanDefinitionNames() : 스프링에 등록된 모든 빈 이름 조회
- ac.getBean(빈이름, 타입) : 빈 이름으로 빈 객체(인스턴스)를 조회
(2) 애플리케이션 빈만 출력하기
  : 스프링 내부 자체 빈 제외하고, 내가 등록한 빈만 출력하려는 것
- getRole()을 사용해 구분
  -> Role ROLE_APPLICATION : 직접 등록한 애플리케이션 빈
  -> Role ROLE_INFRASTRUCTURE : 스프링이 내부에서 사용하는 빈 (자체 빈)
(3) 스프링 컨테이너에서 스프링 빈 찾는 가장 기본적인 조회 방법!
- ac.getBean(빈이름, 타입)
- ac.getBean(타입)
=> 조회 대상 스프링 빈이 없으면 예외 발생 (NoSuchBeanDefinitionException)
(4) 동일한 타입 둘 이상
: 타입으로 조회시 같은 타입의 스프링 빈 둘 이상이면 오류 발생함. 따라서 이때는 빈 이름을 지정해야함!
- ac.getBeansOfType() : 해당 타입의 모든 빈 조회
=> 리턴값이 Map<String, MemberRepository>형태임!
(5) 스프링 빈 조회-상속관계
: 부모 타입으로 조회하면, 자식 타입도 함께 조회한다. 즉, 부모 + 부모를 implements하고 있는 자식 타입도 다 줄줄이 끌려나온다.
=> 이런 이치로, 모든 자바 객체의 최고 부모인 'Object'타입으로 조회한다면, 모든 스프링 빈 조회됨.
==> 지금껏 설명한 bean 조회에 대한 전반적인 기능들은 사실 실제로 이런식으로 구현할 일은 거의 없다. 그러나, bean 원리를 이해할 수 있도록 돕고, 위와 같은 케이스들(부모 타입 조회시, 자식 타입 중복될 때 발생하는 에러 등)을 어떻게 다룰지에 대해 배우기 위함임. 또한, 언젠가 순수한 자바에서 스프링 구현해야할 때 이렇게 실제 쓰기도 하기 때문.

<BeanFactory와 ApplicationContext> => 둘다 스프링 컨테이너라고 부름
1. BeanFactory
- 스프링 컨테이너의 최상위 인터페이스! (조상님)
- 스프링 빈 관리, 조회하는 역할
- getBean() 제공
- 실습에서 우리가 사용한 대부분의 기능은 BeanFactory가 제공하는 기능임
2. ApplicationContext
- BeanFactory의 기능을 모두 상속받아 제공함
- 빈팩토리가 제공하는 빈 관리, 조회하는 기능 외에, 부가기능을 제공하기 위해 사용!
- beanFactory 직접 사용할 일 거의 없고, 부가기능 포함된 ApplicationContext를 사용함
- ApplicationContext가 제공하는 부가기능 (상속받고 있는 인터페이스들) 간단 정보
 a. 메시지소스를 활용한 국제화 기능
  : 예를 들어 메시지 출력시, 한국에서 들어오면 한국어로, 영어권이면 영어로 출력
 b. 환경변수
  : 로컬, 개발, 운영 등을 구분해서 처리
 c. 애플리케이션 이벤트
  : 애플리케이션 내 이벤트 발행하고 구독하는 모델을 편리하게 지원
 d. 리소스 조회
  : 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회하여 내부에서 쓰기 편하게 함

<Java가 아닌 XML로 appConfig 설정하기>
- 스프링 컨테이너는 다양한 형식의 설정 정보 받아드릴 수 있음 (java, XML, groovy 등)
   => AppConfig.class, appConfig.xml, appConfig.xxx
- 최근엔, 스프링 부트 많이 사용하면서 java를 많이 사용하고 XML기반 설정 잘 사용하지 않음. 그래도 예전엔 xml 자주 썼었고, 컴파일 없이 빈 설정 정보 바로 변경가능하기 때문에 배워두면 괜찮다.
- 방법 
  => GenericXmlApplicationContext를 사용하여 xml 설정 파일 넘기면 됨
  => xml 파일은 src/main/resources에 넣기 (java코드 아닌 건 다 여기 넣는다고 생각하면 됨)
     -> xml파일은 new - file 해서 이름을 appConfig.xml로 잡아서 문서에 있는 형식 복붙해넣거나, xml - spring config 있으면 그거 사용(근데 아마 엔터프라이즈 버전에만 이거 있을거임ㅠ)
  => appConfig.xml에 빈, 생성자 등을 등록하면 됨~ java의 AppConfig.class랑 구조는 걍 똑같음.

 <스프링 "빈 설정 메타 정보" = BeanDefinition>
1. 스프링은 어떻게 이런 위와 같은 다양한 설정 형식 지원하는걸까? 그건 바로 BeanDefinition이라는 추상화 덕분! 
  => java든 xml이든 뭐가 됐든 그걸 읽어서 BeanDefinition으로 만들면 된다. 스프링 컨테이너는 java인지 xml인지 뭐든지 몰라도 되고 걍 BeanDefinition만 알면 됨. (beanDefitinion자체가 인터페이스임)
2. BeanDefinition(=빈 설정 메타정보)는 bean의 정보를 추상화시켜버린다. 즉, 역할과 구현을 개념적으로 나눈다.
  - bean 하나 당 각각 하나씩 메타 정보 생성된다. (자바의 @Bean, xml의 <bean> 하나 당)
  - 스프링 컨테이너는 이 메타정보를 기반으로 스프링 빈을 생성한다
3. BeanDefinition 정보
  - 각 요소와 그 정보는 수업 자료 참고
4. 정리
  - BeanDefinition을 직접 생성해서 스프링 컨테이너에 등록할수도 있지만, 실무에서 직접 그럴일은 거의 없으니까, 어려우면 그냥 넘어가도 된다고 하심~
  - BeanDefinition에 대해 너무 깊이있게 이해할 필욘 없고, 스프링이 다양한 형태의 설정 정보를 BeanDefinition으로 추상화해서 사용한다는 것 정도만 이해하면 됨. 그리고 BeanDefinition이라는 단어가 대충 뭐고 어떤 매커니즘인지만 이해하면 됨.

<싱글톤>
: 객체가 1개 뿐
1. 웹 애플리케이션과 싱글톤
: 대부분의 스프링 애플리케이션은 웹 애플리케이션인데, 웹 애플리케이션은 보통 여러 고객이 동시에 요청한다.
- 스프링 없는 순수한 DI 컨테이너 사용시, 객체 매번 새로 생성
  => 고객 100명이 요청하면, 요청 올 때마다 객체 생성되고 소멸된다 => 메모리 낭비!
  => 해결 방안 : 해당 객체 1개만 생성하고, 이걸 공유하도록 설계 => 이게 싱글톤 패턴!
2. 싱글톤 패턴
: 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴
- 객체 인스턴스 2개 이상 생성하지 못하도록 막기 위해,  private 생성자 사용!!! (이래서 사용하는 것..!)
(1) 싱글톤 적용
 a. static 영역에 객체 instance 미리 하나 생성해서 올려둠
    * static이면, static 영역에 이 메서드 하나만 올라감(??)
 b. 이 객체 인스턴스 필요하면 오직 getInstance() 메서드로만 조회가능하며, 이 메서드 호출하면 항상 같은 인스턴스 반환함
 c. 딱 1개 객체 인스턴스만 존재해야 하므로, 생성자를 private으로 막아서 외부에서 new 키워드로 객체 인스턴스 생성되는 것 막는다
=> 싱글톤 패턴 구현하는 방법은 여러가지 있는데, 여기선 객체 미리 생성해두는 가장 단순 안전한 방법 택함
(2) 스프링은 객체를 알아서 싱글톤하게 사용함
3. 싱글톤 패턴의 수많은 문제점
- 코드 자체가 길..다
- 클라이언트가 구체에 의존 => DIP 위반, OCP 위반
- 테스트하기 어려움
- 내부 속성 변경 초기화 어려움
- private으로 자식 클래스 만들기 어려움
- 결론적으로 유연성 떨어짐
- 안티패턴으로 불리기도 함
4. 싱글톤 패턴을 해결한 것 : 싱글톤 컨테이너

<싱글톤 컨테이너>
: 스프링 컨테이너는 싱글톤 패턴 문제점 해결하면서, 객체 인스턴스롤 싱글톤(1개)로 관리
=> 스프링 빈은 싱글톤으로 관리됨!
1. 스프링은 싱글톤 방식!
- 스프링 컨테이너는 알아서 객체 인스턴스를 싱글톤으로 관리함
- 즉 스프링 컨테이너는 싱글톤 컨테이너 역할. (싱글톤 레지스트리)
- 싱글톤 패턴의 모든 단점 해결하면서 객체를 싱글톤으로 유지하게 해줌
  -> 지저분한 코드 들어가지 않아도 되고, DIP, OCP, 테스트, private 생성자로부터 자유롭게 싱글톤 사용가능
*참고 : 스프링 기본 빈 등록 방식이 싱글톤이지만, 싱글톤 외에도 요청할 때마다 새로운 객체 생성하게 해주는 기능도 제공하긴 함
2. 싱글톤 방식의 주의점
: 하나의 같은 객체 인스턴스 공유하므로, 상태를 유지(stateful)하게 설계하면 안됨!
=> 무상태(stateless)로 설계해야 함!! (중**요**)
 - 특정 클라이언트에 의존적인 필드, 값 변경할 수 있는 필드 있으면 안됨
 - 가급적 읽기만 가능
 - 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, threadLocal을 사용해야 함
=> 즉, price는 공유되는 필드인데, 특정 클라이언트가 값을 변경해버린다
        // 공유필드를 조심하고 무상태로 설계해라!

<@Configuration과 싱글톤>
- AppConfig를 보면 memberService와 orderService에서 memberRepository를 각각 한번씩 호출하여 총 2개의 객체가 생겨 싱글톤 깨지는 것처럼 보인다.
=> 실습에서 직접 테스트해서 확인해봤을때 알 수 있듯이, 싱글톤 보장되는 것 알 수 있다.

<@Configuration과 바이트코드 조작>
- 스프링 컨테이너는 싱글톤 레지스트리임. 따라서 스프링 빈이 싱글톤 되도록 보장해준다. 어떻게? 바로 @Configuration을 적용한 AppConfig를 통해!
- 사실 AnnotationConfigApplicationContext에 파라미터로 넘긴 값은 스프링 빈으로 등록됨.
AppConfig도 스프링 빈이 됨. 이건, AppConfig 클래스를 상속받은 다른 클래스 AppConfig@CGLIB를 만들어서 걔를! 스프링 빈으로 등록한다!
  => AppConfig를 조회하면 얘도 조회 가능함 왜냐면 상속했기 땜에!
- 이 임의의 다른 클래스가 바로 싱글톤 보장되도록 해주는 것!!!
  => @Bean 붙은 메서드마다 스프링 빈 존재하면 반환하고, 없으면 생성해서 스프링 빈 등록하여 반환하는 코드가 동적으로 만들어짐

- 싱글톤 보장하는 @Configuration 안 붙이고 @Bean만 적용하면 어케 됨?? 
  => 스프링 빈으로 등록은 가능하지만, 싱글톤은 깨짐 ㅎ
=> 요약 : 스프링 설정 정보는 항상 @Configuration을 사용해 싱글톤을 보장해주자!

<컴포넌트 스캔과 의존관계 자동 주입>
- @Bean이나 <bean>으로 일일이 스프링 빈 등록하기 힘들다..! 이를 해결하기 위해
1. 설정 정보 없어도 자동으로 스프링 빈 등록하는 "컴포넌트 스캔" 기능 제공
2. 의존관계 자동으로 주입하는 "@Autowired" 기능 제공
- 사용방법 :
1. (기존과 동일하게) AppConfig 클래스에 @Configuration 붙여줌
2. 그 아래에 @ComponentScan 붙여줌
   => (필요시 필터 걸어줄수도 있음)

싱글톤 방식의 주의점


------------------------------------------------------------------------------

<단축키>
- 단축키 보는 법 : preferences에서 keymap
- alt + insert : getter, setter / implements method 등 자동 완성
- ctrl + shift + enter : 코드 자동 완성 시 세미콜론까지 찍히게 해주는 단축키
- psvm 치고 enter : public static void main 자동 완성
- ctrl + alt + v : new 객체a 이하만 작성하고 맨 뒤에서 해당 단축키 써주면 앞부분은 자동 완성됨 
- soutv 치고 enter : 위 객체 출력println하는 단축키
- F2 : 오류난 곳으로 바로 이동
- /** 입력후 enter : 주석 한 세트로 자동 완성됨
- ctrl + shift + t : 메서드명 위에서 클릭시, test 만들기 창 뜸 => test 패키지 내에 같은 경로로 test 클래스 생성해줌
- alt + enter : 호출한 메서드 앞에서 클릭시, ondemand static method로 고정(해당 클래스에서 정적 메소드로 고정) => ex) Assertions.assertThat을 assertThat으로 생략 가능 (static import를 찾아보라)
- ctrl + e : 최근 메서드 작업 기록 나옴
- ctrl + shift + f : 전체 검색
- ctrl + shift + r : 전체 검색 및 replace
- iter치고 tap : 리스트나 iterator 아랫줄이나 근처에서 이 단축키 쓰면, 해당 iterator에 대한 for문 자동생성됨.
- soutm치고 enter : 현재 위치한 메서드명을 텍스트형태로 출력
<내가 필요에 의해 찾은 단축키>
- ctrl + y : 줄삭제
- ctrl + d : 줄복제 (한번에 여러줄도 가능)
- shift + Enter : 커서 아랫줄에 빈줄 추가
- ctrl + r : 바꾸기
- ctrl + shift + z : redo
- ctrl + delete/backSpace : 커서 뒷단어/앞단어 삭제
http://ngknightlamune.blogspot.com/2017/06/intellij.html

<기능>

<실무에서는>


<찾아볼 것>
- isSameAs와 isEqualTo의 차이
- static
