1. IOC (제어의 역전)
: 프로그램 제어 흐름을 객체가 직접 제어하는 것이 아니라 외부에서 관리하는 것
(기존) 
- 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성, 연결, 실행했다. 즉, 구현 객체가 프로그램의 제어 흐름을 스스로 조종.
(AppConfig등장이후) 
- 구현 객체는 자신의 로직 실행하는 역할만 담당. 제어 흐름은 AppConfig가 가져감

* 프레임워크 vs 라이브러리
- 프레임워크는 내가 작성한 코드 제어하고 대신 실행해줌. (ex. 테스트 프레임워크의 JUnit)
- 내가 작성한 코드가 직접 제어의 흐름 담당하면, 그건 라이브러리임.

2. DI (의존관계 주입) 과 그 장점
: ServiceImpl는 interface에 의존한다. 실제 어떤 구현 객체가 사용될지는 모른다.
=> 의존관계는 "정적인 클래스 의존 관계"와, "실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계" 둘을 분리해서 생각해야 한다.
(1) 정적인 클래스 의존관계 => 클래스 다이어그램
: 클래스가 사용하는 import 코드만 보고 의존관계 쉽게 판단 가능. 
- 애플리케이션 실행하지 않아도 분석 가능 (툴로 분석 가능. 우클릭 다이어그램-show 다이어그램-show dependency) 
* 의존관계와 화살표 : 화살표가 나오는 곳은 화살표가 가리키는 곳을 의존한다 (도형에서 나가는 화살표가 없다면, 해당 도형(객체)가 의존하는 게 없는 것)
- 클래스 의존관계만으로는 어떤 객체가 주입될 지 알 수 없다.
(2) 동적인 객체 인스턴스 의존관계 => 객체 다이어그램
: 애플리케이션 실행시켜봐야 알 수 있다. 즉, 애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계다
(3) "의존관계 주입"(DI) : 애플리케이션 실행시점(런타임)에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결되는 것
- 객체 인스턴스를 생성하고 그 참조값을 전달해서 연결함
(4) 의존관계 주입의 장점
- 의존관계 주입 사용하면, 클라이언트 코드 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스 변경 가능
- 의존관계 주입 사용하면, 정적인 클.래.스 의존관계 변경하지 않고, 동적인 객.체. 인.스.턴.스의 의존관계 쉽게 변경가능 

3. IOC 컨테이너 = DI 컨테이너 ( '=. AppConfig)
: AppConfig처럼 객체 생성하고 관리하면서, 의존관계 연결해주는 것. 즉, AppConfig처럼 의존관계의 역전 일으키는, 즉 의존관계 주입을 대신 해주는 존재!
- 의존관계 주입에 초점을 맞추어, 최근에는 주로 DI 컨테이너라 부름
- 또는 어셈블러(레고처럼 조립하는 존재), 오브젝트 팩토리(객체 만들어내는 곳) 등으로 불리기도 함.


=> 이제! 스프링으로 전환할 순서! 지금까지 순수한 자바 코드만으로 DI를 적용했지만, 이제 스프링을 사용해 DI의 맛을 제대로 볼 것이다.


